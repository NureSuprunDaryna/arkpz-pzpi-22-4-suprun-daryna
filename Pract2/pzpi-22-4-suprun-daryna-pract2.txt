Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії








Практична робота
з дисципліни: “Аналіз та рефакторинг коду”
на тему:  «Методи рефакторингу коду програмного забезпечення»












Виконала:
 ст. гр ПЗПІ-22-4
Супрун Дарина Андріївна


9 жовтня 2024 р.


Перевірив: 
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович








Харків 2024
1 МЕТА


Навчити студентів основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проєктів. Студенти повинні навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.


2 ЗАВДАННЯ


Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
        Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
        Кожен метод рефакторингу повинен супроводжуватись:
1. описом проблеми, яку вирішує даний метод;
2. кодом до і після застосування методу рефакторингу;
3. поясненням переваг використаного методу.


________________


3 ХІД РОБОТИ
1. Replace Array with Object (Заміна масиву на об'єкт)
        Проблема: Масиви в C# (як і в багатьох мовах) часто використовуються для зберігання даних, проте можуть викликати труднощі, коли різні індекси використовуються для зберігання різнорідних даних. Коли програмісту потрібно звернутись до елементу масиву, код стає менш зрозумілим, оскільки важко відразу зрозуміти, що саме представляє кожен елемент масиву. Це також ускладнює підтримку та розширення коду.
        Рішення: Створення окремого класу або об'єкта з полями, які явно представляють дані, робить код більш зрозумілим. Поля класу можуть мати зрозумілі назви, що дозволяє уникнути плутанини з індексами масиву. Об'єкт забезпечує більшу гнучкість: можна додавати нові властивості, методи або валідацію, що неможливо реалізувати при використанні простого масиву.
        Пояснення: Коли ви використовуєте масив, кожен елемент масиву звертається за індексом, і компілятор не може перевірити, чи правильно ви використовуєте індекси. Це призводить до "магічних чисел", що ускладнює зрозумілість коду. Заміна масиву на об'єкт вирішує ці проблеми за допомогою строгих типів, що дозволяє скористатися компілятором для перевірки правильності доступу до полів об'єкта.
До:
class Employee
{
    private string[] employeeDetails = new string[2];  // Масив для зберігання імені та посади


    public Employee(string name, string position)
    {
        employeeDetails[0] = name;        // employeeDetails[0] представляє ім'я
        employeeDetails[1] = position;    // employeeDetails[1] представляє посаду
    }


    public void PrintDetails()
    {
        Console.WriteLine("Name: " + employeeDetails[0]);
        Console.WriteLine("Position: " + employeeDetails[1]);
    }
}
Після:
class Employee
{
    private string name;        // Поле для імені
    private string position;    // Поле для посади


    public Employee(string name, string position)
    {
        this.name = name;            // Пряме присвоєння
        this.position = position;
    }


    public void PrintDetails()
    {
        Console.WriteLine("Name: " + name);
        Console.WriteLine("Position: " + position);
    }
}
Переваги:
1. Сильна типізація: використовуються строго визначені поля, що зменшує кількість помилок. 
2. Легкість у розширенні: якщо потрібно додати нові атрибути (наприклад, дату народження), це легко зробити, додавши нові поля. 
3. Чіткість: кожне поле об'єкта має чітку назву, що полегшує розуміння коду.


2. Replace Error Code with Exception (Заміна коду помилки на виняток)
Проблема: У старих системах або в мовах без підтримки винятків часто використовуються коди помилок (як-от цілі числа), які інформують про те, чи успішно виконалася функція. Це призводить до того, що програміст повинен вручну перевіряти кожен код повернення і в залежності від нього приймати рішення. Такий підхід призводить до зростання складності, особливо коли коди помилок ігноруються, або коли багато перевірок на успішність можуть затуманювати логіку.
        Рішення: Замість того, щоб використовувати коди помилок, винятки дозволяють використовувати вбудований механізм мови C# для обробки помилок. Винятки можуть бути легко відловлені за допомогою try-catch, що дозволяє краще ізолювати бізнес-логіку від обробки помилок.
        Пояснення: Винятки автоматично передаються вгору по стеку викликів, якщо їх не обробити на нижчих рівнях, що значно полегшує обробку помилок. Використання винятків дозволяє відокремити основну логіку від обробки помилок і зосередитись на продуктивному коді.
До:
class FileReader
{
    public const int SUCCESS = 0;
    public const int FILE_NOT_FOUND = 1;


    public int ReadFile(string filePath)
    {
        if (!File.Exists(filePath))
        {
            return FILE_NOT_FOUND; // Код помилки
        }
        // Логіка читання файлу
        return SUCCESS;
    }
}
Після:
class FileReader
{
    public void ReadFile(string filePath)
    {
        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException("The file was not found: " + filePath); // Викидання винятку
        }
        // Логіка читання файлу
    }
}
Переваги:
1. Ясність: чітко відокремлюється код логіки програми від коду обробки помилок.
2. Автоматична передача: винятки не потрібно повертати та перевіряти вручну — вони автоматично піднімаються по стеку.
3. Стандартний механізм: C# має потужну вбудовану підтримку винятків із можливістю логування, обробки та фільтрації винятків.
3. Replace Exception with Test (Заміна винятку на перевірку)
Проблема: Винятки є потужним інструментом для обробки помилок, але їх не варто використовувати для звичайних умов, таких як перевірка вхідних даних. Використання винятків для таких сценаріїв може призвести до надмірних накладних витрат на обробку винятків, оскільки вони використовують багато системних ресурсів.
        Рішення: Замість того, щоб кидати винятки для передбачуваних ситуацій, слід використовувати умовні перевірки (валидацію) для уникнення помилок. Це підвищує продуктивність і дозволяє виконувати обробку без накладних витрат, пов'язаних із винятками. 
        Пояснення: Винятки в C# використовують механізм стека викликів для "пробросу" помилки вгору по ланцюгу викликів, що може бути повільним. Для очікуваних умов (наприклад, погані вхідні дані) краще використовувати валідацію або умовні оператори. Це дозволяє коду швидше виконуватися та уникати використання ресурсоємної механіки винятків.
До:
class User
{
    public void SetAge(int age)
    {
        if (age < 0)
        {
            throw new ArgumentException("Age cannot be negative"); // Кидання винятку для поганих даних
        }
        // Логіка для встановлення віку
    }
}
Після:
class User
{
    public bool SetAge(int age)
    {
        if (age < 0)
        {
            return false;  // Використання перевірки замість винятку
        }
        // Логіка для встановлення віку
        return true;
    }
}


Переваги:
1. Продуктивність: умовні перевірки швидші і менш затратні за винятки.
2. Передбачуваність: умови, які очікуються в ході роботи програми (наприклад, некоректні вхідні дані), краще обробляти через перевірки.
3. Зменшення складності: код стає легшим у розумінні, оскільки винятки обробляються лише для дійсно несподіваних ситуацій.
________________


ВИСНОВКИ
Оволодіння навичками рефакторингу сприяє створенню кращого коду, що забезпечує вищу продуктивність, легкість у підтримці та розширенні, а також загальну зрозумілість програмних рішень.
        Replace Array with Object дозволяє підвищити чіткість і структурованість коду, оскільки заміна масиву на об'єкт сприяє більш наочній організації даних та їх типізації. Це полегшує підтримку і розширення коду завдяки використанню іменованих полів замість індексів масиву.
        Replace Error Code with Exception значно спрощує обробку помилок, роблячи її більш надійною та стандартизованою. Винятки дозволяють ізолювати основну логіку від обробки помилок, автоматично передаючи інформацію про них по стеку викликів, що робить код більш чистим і зрозумілим.
        Replace Exception with Test допомагає зменшити накладні витрати на використання винятків для передбачуваних умов. Заміна винятків на умовні перевірки дозволяє зробити програму ефективнішою з точки зору продуктивності та забезпечує передбачувану обробку типових помилок, таких як валідація вхідних даних.
        Посилання на відео-доповідь: https://youtu.be/NjBOWv1tHTk
________________
4 ДОДАТОК А 


Презентація до доповіді 
Рисунок А.1 – Титульний слайд презентації   


  



Рисунок А.2 – Перший метод рефакторингу з прикладом
  

Рисунок А.3 – Продовження прикладу до першого методу


  

Рисунок А.4 – Другий метод рефакторингу з прикладом




Рисунок \А.5 – Продовження прикладу до другого методу  


  

Рисунок А.6 – Третій метод рефакторингу з прикладом
________________
Рисунок А.7 – Продовження прикладу до третього методу  
  

Рисунок А.8 – Слайд-висновки
________________
  
Рисунок А.9 – Слайд-список використаної літератури