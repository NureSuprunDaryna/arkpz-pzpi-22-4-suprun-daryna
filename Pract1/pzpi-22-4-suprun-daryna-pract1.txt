Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії








Практична робота
з дисципліни: “Аналіз та рефакторинг коду”
на тему:  «Правила оформлення програмного коду.»












Виконала ст. гр ПЗПІ-22-4
Супрун Дарина Андріївна


28 вересня 2024 р.


Перевірив 
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович










Харків 2024
1 МЕТА


Ознайомити студентів з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для різних мов програмування, а також навчити аналізувати та рефакторити код для покращення його якості.


2 ЗАВДАННЯ


Студент повинен обрати мову програмування, дослідити основні рекомендації для написання якісного коду у цій мові, продемонструвати ці рекомендації на прикладах коду, обґрунтувати кожну рекомендацію і надати детальні пояснення. Для кожного прикладу мають бути наведені фрагменти коду.
________________


3 ХІД РОБОТИ


Для виконання завдання було обрано тему С#.  У цьому розділі будуть викладені основні рекомендації щодо написання чистого та ефективного коду, що допоможе підвищити його читабельність, зрозумілість та простоту у підтримці. Кожна рекомендація супроводжується поясненням та фрагментами коду, які ілюструють практичне застосування цих принципів:
1. Використовуйте осмислені назви змінних, функцій та класів.
Опис: імена змінних, функцій та класів повинні бути осмисленими та зрозумілими для будь-якого розробника, який читає код. Це означає, що імена мають чітко описувати їх призначення, що полегшує розуміння коду та співпрацю в команді. Для цього необхідно уникати абстрактних назв і завжди враховувати контекст застосування. Хороші імена мають бути інтуїтивно зрозумілими, що значно скорочує час на аналіз і виправлення коду.
        Чому важливо: зрозумілі імена зменшують кількість помилок та час, що витрачається на розуміння коду. Програмістам, які працюють над проектом після вас, буде легше читати код, що сприяє кращій підтримці та розширенню проекту.
Поганий приклад:
int x = 10;
string str = "Привіт";
Гарний приклад:
int userAge = 10;
string greetingMessage = "Привіт";
2. Дотримуйтесь чіткої структури коду. Кожен метод чи клас має відповідати лише одній задачі.
        Опис: код повинен бути чітко структурованим з логічним поділом на класи та методи, кожен з яких вирішує лише одну задачу. Це дозволяє краще розуміти код і легко вносити зміни. Чітка структура допомагає не тільки в розробці, але й у підтримці великих проектів, де одна зміна може впливати на багато компонентів. Якщо кожен метод і клас мають єдине призначення, це зменшує ймовірність помилок і підвищує модульність коду.
        Чому важливо: чітка структура коду дозволяє швидко знаходити необхідні частини програми та мінімізує ризик виникнення конфліктів при зміні функціоналу.
Поганий приклад:
public class User
{
    public string Name { get; set; }
    public string Email { get; set; }


    public void SendEmail(string message)
    {
        // Логіка відправки електронного листа
    }


    public void SaveToDatabase()
    {
       // Логіка збереження користувача в базі даних
    }
}


Гарний приклад:


public class User
{
    public string Name { get; set; }
    public string Email { get; set; }
}


public class EmailService
{
    
   public void SendEmail(User user, string message)
    {
        // Логіка відправки електронного листа
    }
}


public class UserRepository
{
    public void Save(User user)
    {
        // Логіка збереження користувача в базі даних
    }
}
3. Дотримання стилю кодування
        Опис: код має бути написаний у відповідності з єдиним стилем, наприклад, згідно з рекомендаціями Microsoft (Microsoft C# Coding Conventions). Стиль кодування включає відступи, пробіли, розміщення дужок та інші дрібниці, які роблять код послідовним і зручним для читання. Використання стандартизованих правил дозволяє всім учасникам проекту швидко розуміти написане.
        Чому важливо: узгоджений стиль коду допомагає знизити кількість помилок, пов'язаних із неправильною інтерпретацією коду, і полегшує співпрацю в команді.
Поганий приклад:
public class user{
public void DoSomething(){Console.WriteLine("Hello");}}
Гарний приклад:
public class User
{
    public void DoSomething()
    {
        Console.WriteLine("Hello");
    }
}
Наслідки недотримання: непослідовний стиль коду робить його важким для читання та підтримки.
4. Уникайте дублювання коду (DRY — Don't Repeat Yourself)
        Опис: принцип DRY (Don’t Repeat Yourself) означає, що один і той самий код не повинен повторюватися в різних місцях програми. Якщо певна логіка використовується кілька разів, її варто винести в окремий метод чи клас. Це знижує ймовірність помилок, полегшує тестування і робить код більш чистим та підтримуваним.
        Чому важливо: дублювання коду може призвести до неузгодженостей і помилок при внесенні змін. Винесення повторюваного коду в окремі методи підвищує гнучкість та зручність у підтримці.
Поганий приклад:
public void CreateUser(string name, string email)
{
    Console.WriteLine("Creating user...");
    // Логіка створення користувача
}


public void DeleteUser(int userId)
{
    Console.WriteLine("Deleting user...");
    // Логіка видалення користувача
}
Гарний приклад:
public void LogOperation(string operation)
{
    Console.WriteLine(operation);
}


public void CreateUser(string name, string email)
{
    LogOperation("Creating user...");
    // Логіка створення користувача
}


public void DeleteUser(int userId)
{
    LogOperation("Deleting user...");
    // Логіка видалення користувача
}
Наслідки недотримання: дублювання коду ускладнює його тестування і підтримку.
        5. Обробка помилок та винятків
        Опис: правильна обробка помилок забезпечує стабільність і безперервність роботи програми. У C# для цього використовуються блоки try-catch, що дозволяють коректно реагувати на виключні ситуації без завершення роботи програми.
        Чому важливо: без належної обробки винятків програма може аварійно завершити роботу, що негативно позначається на користувацькому досвіді.
Поганий приклад:
int result = 10 / 0;  // Помилка ділення на нуль, програма припинить роботу
Гарний приклад:
try
{
    int result = 10 / 0;
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Помилка: ділення на нуль");
}
Наслідки недотримання: програма може аварійно завершитися, що погіршує досвід користувачів.
        6. Використовуйте асинхронні методи для тривалих операцій
        Опис: асинхронні методи (async та await) дозволяють виконувати тривалі операції без блокування основного потоку. Це забезпечує більш плавну роботу програми, особливо для інтерфейсів користувача.
        Чому важливо: якщо не використовувати асинхронність, програма може зависати під час виконання тривалих завдань, що погіршує взаємодію з користувачем.
Поганий приклад:
public void FetchData()
{
    Thread.Sleep(2000);  // Блокує потік на 2 секунди
    Console.WriteLine("Дані завантажені.");
}
Гарний приклад:
public async Task FetchDataAsync()
{
    Console.WriteLine("Завантаження даних...");
    await Task.Delay(2000);  // Не блокує основний потік
    Console.WriteLine("Дані завантажені.");
}
Наслідки недотримання: блокування основного потоку може призвести до зависань програми або затримок в інтерфейсі.
        7. Пишіть тести для свого коду
        Опис: юніт-тестування забезпечує стабільність і правильність роботи програми на всіх етапах розробки. Це дозволяє швидко виявляти та виправляти помилки, що особливо важливо під час рефакторингу або додавання нового функціоналу.
        Чому важливо: без тестів важко гарантувати стабільність коду після внесення змін. Тести знижують ризик несподіваних багів у коді.
Поганий приклад: 
         // Відсутність тестування
Гарний приклад:
[TestMethod]
public void TestMultiplyByTwo()
{
    int result = MultiplyByTwo(5);
    Assert.AreEqual(10, result);
}
        Наслідки недотримання: без тестів помилки можуть залишатися непоміченими до етапу використання кінцевими користувачами.


8. Використовуйте ефективні алгоритми та оптимальні рішення для покращення продуктивності.
Опис: вибір правильних алгоритмів і оптимальних рішень впливає на загальну продуктивність системи, особливо коли мова йде про великі проекти чи додатки з великим навантаженням. Важливо використовувати добре продумані структури даних і алгоритми для зменшення складності та ресурсоємності.
        Чому важливо: оптимальні рішення зменшують затримки в роботі програм, дозволяючи їм працювати швидше і стабільніше. Це критично для користувацького досвіду, особливо в реальних системах з великими обсягами даних або в інтенсивних обчислювальних процесах.
        Наслідки недотримання: неефективні алгоритми можуть значно погіршити продуктивність, збільшити час обробки задач і підвищити використання ресурсів, що ускладнює масштабування і стабільну роботу додатка.
        Як впливає на підтримку коду: оптимальний код не лише працює швидше, але й потребує менше змін у майбутньому. Погано продумані рішення можуть вимагати постійної оптимізації та можуть бути важкими для підтримки в процесі росту системи.
Поганий приклад (неефективний алгоритм):
public class MaxFinder
{
    public int FindMax(int[] numbers)
    {
        int maxValue = numbers[0];
        for (int i = 0; i < numbers.Length; i++)
        {
            for (int j = i + 1; j < numbers.Length; j++)
            {
                if (numbers[j] > maxValue)
                {
                    maxValue = numbers[j];
                }
            }
        }
        return maxValue;
    }
}
Хороший приклад (оптимізований алгоритм):
public class MaxFinder
{
    public int FindMax(int[] numbers)
    {
        return numbers.Max();
    }
}
        9. Дотримуйтеся парадигм програмування (ООП, функціональне) відповідно до проекту.
        Опис: різні типи програмних систем вимагають використання різних парадигм програмування. Наприклад, об'єктно-орієнтоване програмування (ООП) добре підходить для складних проектів з багатьма залежностями, тоді як функціональне програмування більш підходить для роботи з чистими функціями та відсутністю змінних станів.
        Чому важливо: дотримання парадигм дозволяє підтримувати узгодженість архітектури проекту, забезпечуючи зрозумілий і передбачуваний код. Це полегшує роботу команди і пришвидшує процес розробки.
Наслідки недотримання: нехтування парадигмами програмування призводить до створення непослідовного коду, де важко зрозуміти логіку і де можуть бути змішані різні підходи. Це збільшує ризик помилок і значно ускладнює майбутні зміни.
        Як впливає на підтримку коду: чітке дотримання парадигми робить код більш передбачуваним та зрозумілим для інших розробників, що полегшує підтримку та внесення змін. Невідповідність парадигм ускладнює підтримку і може вимагати значного переписування в майбутньому.
Поганий приклад (змішування парадигм):
public class Animal
{
    public string Name { get; set; }


    public Animal(string name)
    {
        Name = name;
    }
}


public class SoundMaker
{
    public void MakeSound(Animal animal)
    {
        if (animal.Name == "Dog")
        {
            Console.WriteLine("Woof!");
        }
        else if (animal.Name == "Cat")
        {
            Console.WriteLine("Meow!");
        }
    }
}
Гарний приклад (дотримання ООП):
public abstract class Animal
{
    public string Name { get; set; }


    public Animal(string name)
    {
        Name = name;
    }


    public abstract void MakeSound();
}


public class Dog : Animal
{
    public Dog(string name) : base(name) {}


    public override void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
}


public class Cat : Animal
{
    public Cat(string name) : base(name) {}


    public override void MakeSound()
    {
        Console.WriteLine("Meow!");
    }
}


// Використання
var dog = new Dog("Dog");
dog.MakeSound();


var cat = new Cat("Cat");
cat.MakeSound();


10. Завжди документуйте свій код за допомогою коментарів та XML-документації.
        Опис: документація є невід'ємною частиною розробки програмного забезпечення. Добре написані коментарі та XML-документація допомагають розробникам швидко орієнтуватися в коді та розуміти його логіку, що знижує ймовірність помилок та економить час під час підтримки та розвитку.
        Чому важливо: документування дозволяє легко зрозуміти, як функціонує код, які завдання він виконує, а також швидко розібратися з будь-якою частиною проекту. Це особливо важливо при роботі в команді або при поверненні до коду через деякий час.
        Наслідки недотримання: відсутність коментарів та документації ускладнює розуміння коду, підвищує ризик внесення помилок під час модифікацій та значно збільшує час, необхідний для ознайомлення з проектом.
        Як впливає на підтримку коду: документований код значно легше підтримувати: він економить час на дослідження та розуміння логіки. Відсутність документації може призвести до втрати часу та підвищення ризиків при внесенні змін або додаванні нового функціоналу.
Поганий приклад (без документації):
public class Circle
{
    public double CalculateArea(double r)
    {
        return 3.14 * r * r;
    }
}
Гарний приклад (з документацією):
/// <summary>
/// Клас для розрахунку площі кола.
/// </summary>
public class Circle
{
    /// <summary>
    /// Обчислює площу кола за заданим радіусом.
    /// </summary>
    /// <param name="radius">Радіус кола.</param>
    /// <returns>Площа кола.</returns>
    public double CalculateArea(double radius)
    {
        return 3.14 * radius * radius;
    }
}
        
        У Додатку А наведено програмний код програми, на якій наочно продемонстровано “чистий” код та код, у якому рекомендації було проігноровано. У коді наведено коментарі з поясненнями щодо використання. 
________________


ВИСНОВКИ
У цій доповіді було розглянуто принципи написання чистого коду, їхню важливість у процесі розробки програмного забезпечення та наслідки недотримання рекомендацій. Якість коду є ключовим фактором успіху. Створення якісного коду, що відповідає стандартам, забезпечує легке розуміння та підтримку проекту. Зрозумілий та чистий код дозволяє новим розробникам швидко інтегруватися в проект, а команді — працювати ефективніше.
        Дотримання принципів SOLID та правильне структурування коду дозволяє створювати гнучкі, стабільні та масштабовані програми. Це полегшує модифікацію коду і забезпечує його подальший розвиток з мінімальними витратами ресурсів. Важливо зазначити, що дотримання рекомендацій під час написання коду зменшує технічний борг і кількість помилок у системі, що, у свою чергу, сприяє економії часу та ресурсів під час підтримки й розвитку проекту.
        Ефективність командної роботи також значно покращується, коли всі учасники команди дотримуються єдиних стандартів написання коду. Це полегшує комунікацію між членами команди та дозволяє швидше вносити зміни без ризику порушення загальної архітектури проекту. Проте, якщо не дотримуватися принципів чистого коду, це може призвести до виникнення технічного боргу, складнощів у підтримці, появи неочікуваних помилок та проблем з масштабованістю, що значно ускладнює роботу над проектом у майбутньому і потребує більше зусиль для виправлення.
        Отже, дотримання принципів чистого коду є вирішальним для успішного та довготривалого розвитку програмних продуктів. Це не лише підвищує ефективність команди, але й дозволяє створювати стійкі, легкі в підтримці і гнучкі системи, що можуть адаптуватися до змін у вимогах та умовах.
Посилання на відео-доповідь: https://youtu.be/woIojfvA_dQ
________________
4 ДОДАТОК А 
Програмний код, який демонструє код, у якому було дотримано усіх рекомендацій


using System;
using System.Collections.Generic;
using System.Threading.Tasks;


namespace CleanCodeExample
{
    // 1. Використовуйте осмислені назви змінних, функцій та класів
    // У цьому прикладі ми використовуємо назви, які чітко описують роль кожного класу, методу та змінної.
    public class User
    {
        public string Name { get; set; }
        public string Email { get; set; }
        public string DiscountType { get; set; }


        public User(string name, string email, string discountType)
        {
            Name = name;
            Email = email;
            DiscountType = discountType;
        }
    }


    // 2. Дотримуйтесь чіткої структури коду. Кожен метод чи клас має відповідати лише одній задачі
    public class DiscountService
    {
        private static readonly Dictionary<string, decimal> DiscountRates = new Dictionary<string, decimal>
        {
            { "student", 0.9m },
            { "senior", 0.85m },
            { "employee", 0.8m },
            { "none", 1.0m }
        };


        // Метод обчислює знижку користувача
        public decimal CalculateDiscount(decimal price, string discountType)
        {
            var discountRate = DiscountRates.ContainsKey(discountType) ? DiscountRates[discountType] : 1.0m;
            return price * discountRate;
        }
    }


    // 3. Дотримання стилю кодування (C# Microsoft Coding Conventions)
    public class EmailService
    {
        // Асинхронний метод для надсилання електронного повідомлення
        public async Task SendEmailAsync(User user, string message)
        {
            Console.WriteLine($"Надсилання повідомлення {user.Email}...");
            await Task.Delay(2000);  // Симуляція відправки листа
            Console.WriteLine("Повідомлення надіслано.");
        }
    }


    public class UserRepository
    {
        // Метод для збереження користувача в базі даних
        public void Save(User user)
        {
            Console.WriteLine($"Користувач {user.Name} збережений у базі даних.");
        }
    }


    // 4. Уникайте дублювання коду (DRY)
    // Ми винесли загальний код для логування операцій у метод LogOperation
    public class Logger
    {
        public void LogOperation(string operation)
        {
            Console.WriteLine(operation);
        }
    }


    // Основний клас програми
    public class Store
    {
        private readonly DiscountService _discountService = new DiscountService();
        private readonly EmailService _emailService = new EmailService();
        private readonly UserRepository _userRepository = new UserRepository();
        private readonly Logger _logger = new Logger();


        // Метод для обробки покупки користувача
        public async Task ProcessPurchase(User user, decimal price)
        {
            // Обробка знижки
            var finalPrice = _discountService.CalculateDiscount(price, user.DiscountType);
            _logger.LogOperation($"Користувач {user.Name} отримав знижку. Кінцева ціна: {finalPrice}");


            // Надсилання повідомлення
            await _emailService.SendEmailAsync(user, $"Дякуємо за покупку! Ваша ціна: {finalPrice}");


            // Збереження користувача
            _userRepository.Save(user);
        }
    }


    class Program
    {
        static async Task Main(string[] args)
        {
            // Створення користувача
            var user = new User("Дарина Супрун", "daryna.suprun@nure.ua", "student");


            // Ініціалізація магазину
            var store = new Store();


            // Обробка покупки
            await store.ProcessPurchase(user, 1000m); // Вхідна ціна товару
        }
    }
}




Програмний код, який демонструє код, у якому не було дотримано рекомендацій


using System;
using System.Collections;
using System.Threading;


namespace BadCodeExample
{
    public class U
    {
        public string n;
        public string e;
        public string d;


        public U(string x, string y, string z)
        {
            n = x;
            e = y;
            d = z;
        }
    }


    public class DS
    {
        public decimal calc(decimal p, string t)
        {
            Hashtable rates = new Hashtable();
            rates.Add("a", 0.9m);
            rates.Add("b", 0.85m);
            rates.Add("c", 0.8m);
            rates.Add("none", 1.0m);


            if (!rates.ContainsKey(t)) t = "none";
            return p * (decimal)rates[t];
        }
    }


    public class ES
    {
        public void Send(U u, string m)
        {
            Console.WriteLine("sending..." + u.e);     Thread.Sleep(2000);             Console.WriteLine("sent.");
        }
    }


    public class UR
    {
        public void SaveIt(U u)
        {
            Console.WriteLine(u.n + " saved.");
        }
    }


    public class L
    {
        public void Log(string o)
        {
            Console.WriteLine(o);
        }
    }


    public class S
    {
        DS ds = new DS();
        ES es = new ES();
        UR ur = new UR();
        L l = new L();


        public void Do(U u, decimal p)
        {
            var fp = ds.calc(p, u.d);
            l.Log("discount for " + u.n + ": " + fp);
            es.Send(u, "thanks, you paid " + fp);
            ur.SaveIt(u);
        }
    }


    class P
    {
        static void Main(string[] args)
        {
            U u = new U("User", "user@example.com", "a");
            S s = new S();
            s.Do(u, 1000m);
        }
    }
}
________________


5 ДОДАТОК В 
Презентація до доповіді 
Рисунок В.1 – Титульний слайд презентації   
  



Рисунок В.2 – Слайд-вступ




  

Рисунок В.3 – Перша рекомендація з прикладом
  

Рисунок В.4 – Друга рекомендація з прикладом








Рисунок В.5 – Продовження прикладу до другої рекомендації  


  

Рисунок В.6 – Третя рекомендація з прикладом
________________
Рисунок В.7 – Четверта рекомендація з прикладом  
Рисунок В.8 – Продовження прикладу до четвертої рекомендації
________________
  Рисунок В.9 – П’ята рекомендація з прикладом

Рисунок В.10 – Шоста рекомендація з прикладом    
Рисунок В.11 – Сьома рекомендація з прикладом  


Рисунок В.12 – Восьма рекомендація з прикладом  
Рисунок В.13 – Дев’ята рекомендація з прикладом  
Рисунок В.14 – Десята рекомендація з прикладом  
Рисунок В.15 – Приклад використання рекомендацій у реальному коді  
Рисунок В.16 – Продовження прикладу використання рекомендацій у реальному коді  
  

Рисунок В.17 – Приклад недотримання рекомендацій у коді


Рисунок В.18 – Слайд-висновки
________________
  

  



Рисунок В.19 – Слайд-список використаної літератури